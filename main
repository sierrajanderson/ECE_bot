import discord
from discord import Embed
from discord.ext import commands
from discord.utils import get
from time import asctime, localtime, time

token = "lmaonoyouthinkyouresoclever"
server_id = 945500259868631100
server_name = "2022-ENEL220"
prefix = '!*'

# verification
verification_channel_id = 945500259868631100
welcome_role_id = 945500259868631100

# rules
channel_rules = {"#general":
                     "For general discussion, primarily related to photography and videography.",

                 "#socials and self promotion":
                     "This is the only channel where it is ok to post your social media accounts "
                     "(unsolicited).\n We encourage you to post a brief description of the kind of "
                     "content we can expect to see from your account.\nWe want this to be a "
                     "community, so please, the more information about yourself, the better.",

                 "#troubleshooting":
                     "For when you have a problem with your equipment, and **have googled how to "
                     "fix it first**. The more detail you can provide about your gear the more "
                     "likely it is that your problem can be solved.",

                 "#gear-discussion":
                     "For general discussion of gear. Anything from (camera) bodies to editing "
                     "equipment to that 70TB of storage you just added to your NAS (for sports "
                     "photos right? right?!) is a-okay.",

                 "#photo-gallery":
                     "For sharing your photography! **All** content must belong to you, or you "
                     "must have explicit permission to share it (and credit the owner)",

                 "#photo-general":
                     "For general discussion of photography and related topics.",

                 "#video-gallery":
                     "For sharing your video work! **All** content must belong to you, or you must "
                     "have explicit permission to share it (and credit the owner)",

                 "#video-general":
                     "For general discussion of videography, cinematography and related topics",

                 "#audio-gallery":
                     "For sharing your audio work! **All** content must belong to you, or you must "
                     "have explicit permission to share it (and credit the owner)",

                 "#audio-general":
                     "For general discussion of audio and related topics",

                 "#photo-feedback, #video-feedback & #audio-feedback":
                     "These channels are for **constructive** criticism and review of work that is "
                     "posted in them. \nPlease provide feedback on the most recent post(s) if "
                     "they have not yet received any before posting your own content.",

                 "#off-topic":
                     "For discussion not related to photography, videography or audio.",

                 "#memes":
                     "This is the only place in this server where it is appropriate to share "
                     "memes. Keep them SFW please.\nContent that could be deemed offensive may be "
                     "removed at the discretion of moderators."
                 }
# rules = {"**All content must follow the Discord terms of service.**": "",
#          "Basic internet etiquette applies. Donâ€™t be a dick.": "",
#          "Discrimination or harassment in any form will not be tolerated and will result "
#          "in a ban.": "",
#          "No spamming, and no classified ads or self-promotion outside of designated channels.": "",
#          "NSFW content is not permitted outside of specific R18 spaces.": "",
#          "Images of minors are not permitted.": "",
#          "Ping @moderators if you see rules being broken.":
#              "Please use <#928057972775596073> if you have any ideas for the server! We'll take "
#              "them all into consideration :)",
#          "Users must have a pingable name": "At a minimum the first three characters in your name "
#                                             "must be present on a standard EN-US QWERTY keyboard."
#          }

# roles
roles_channel_id = verification_channel_id
roles = {
    945634624678289418: ("Intermediate", ""),
    945634698640625675: ("First Pro", ""),
    945634788130304051: ("Second Pro", ""),
    945634852630323250: ("Third Pro", ""),
    945634952366678077: ("Graduate", ""),
    945635135989096468: ("Teaching Staff", "")
                }

verifiable_roles = {

}
mod_ping_channel_id = 928040388625858600

# # brands
# brands_channel_id = 928077738236055563
# brands = {
#     931668604984901682: "Canon",
#     931670014648537149: "Nikon",
#     931670146093817906: "Sony",
#     931670206739279933: "Fujifilm",
#     931670316969762867: "Olympus",
#     931670404379062292: "Panasonic",
#     931670424717238292: "Pentax",
#     931670495814897725: "Leitz / Leica",
#     931670540358410250: "Sigma",
#     931670563573858354: "Phase One",
#     931670597971357757: "Hasselblad",
#     931670629411860480: "Contax",
#     931670645778042891: "Mamiya",
#     931670654959357982: "Minolta",
#     931670724677074954: "Yashica",
#
#     931670756218257459: "Drones",
#
#     931670781996441680: "Analog film",
#     931670814112247878: "Large Format",
#     931670860534775948: "Medium Format",
#     931670889173491783: "RED",
#     931670915354357821: "ARRI",
#     931670956315918437: "Grass Valley",
#     931670990797279272: "Blackmagic",
#     931671050763255899: "Vision Research",
#     931671065149734944: "Panavision",
#     931671141557350420: "DJI"
# }  # viewfinders

# continents
continents_channel_id = verification_channel_id
continents = {
    945634355101990965: "Electrical Engineering",
    945634440552546334: "Computer Engineering",
}

# mod_logging
logging_channel_id = 931728159840272434

# globals
COLOUR = discord.Color.from_rgb(65, 102, 145)
MAX_ITEMS_IN_EMBED = int(len(brands) / 2)


class ButtonVerify(discord.ui.Button):
    # a variation of the Button class allowing for one-click verification.
    def __init__(self, bot, welcome_role, server, welcome_message, user_roles,
                 verifiable_user_roles, logging_channel):
        self.logging_channel = logging_channel
        self.bot = bot
        self.welcome_role = welcome_role
        self.server_id = server
        self.welcome_message = welcome_message
        self.user_roles = user_roles
        self.verifiable_user_roles = verifiable_user_roles
        super(ButtonVerify, self).__init__(style=discord.ButtonStyle.green,
                                           label='Click to verify!')

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer()
        guild = await self.bot.fetch_guild(self.server_id)
        user_object = interaction.user
        role_object = get(guild.roles, id=self.welcome_role)
        if role_object in user_object.roles or len(set(user_object.roles).intersection(
                set(guild.get_role(role_id) for role_id in
                    list(self.user_roles.keys()) +
                    list(self.verifiable_user_roles.keys())))) > 0:
            await interaction.followup.send(content=None,
                                            embed=Embed(
                                                title='You\'ve already been verified!',
                                                description="",
                                                colour=COLOUR),
                                            ephemeral=True)

        else:
            await interaction.followup.send(content=None,
                                            embed=Embed(
                                                title='You\'ve been verified!',
                                                description=self.welcome_message,
                                                colour=COLOUR),
                                            ephemeral=True)
            await user_object.add_roles(role_object)
            # await self.logging_channel.send(
            #     f"<@{interaction.user.id}> verified at "
            #     f"{asctime(localtime(time()))}")


class RoleSelect(discord.ui.Select):
    # subclass of 'select', allowing for role manipulation
    def __init__(self, bot, roles, verifiable_roles, mod_ping_channel, server, server_id,
                 welcome_role, placeholder, logging_channel):
        self.logging_channel = logging_channel
        self.bot = bot
        self.user_roles = roles
        self.verifiable_user_roles = verifiable_roles
        self.verify_notification_target = mod_ping_channel
        self.server = server
        self.server_id = server_id
        self.welcome_role = welcome_role
        super(RoleSelect, self).__init__(placeholder=placeholder)

    async def callback(self, interaction: discord.Interaction):
        user = interaction.user
        role = int(interaction.data['values'][0])
        guild = interaction.guild
        welcome_role_item = guild.get_role(self.welcome_role)
        await interaction.response.defer()
        guild_roles = await guild.fetch_roles()

        role_item = list(guild_roles)[[role.id for role in guild_roles].index(role)]

        role_name = role_item.name

        if role not in user.roles:
            if welcome_role_item in user.roles or len(set(user.roles).intersection(
                    set(guild.get_role(role_id) for role_id in
                        list(self.user_roles.keys()) +
                        list(self.verifiable_user_roles.keys())))) > 0:
                if role in self.verifiable_user_roles.keys():
                    # message role_moderator
                    mod_notification_channel = guild.get_channel(self.verify_notification_target)

                    await mod_notification_channel.send(
                        embed=Embed(
                            title=f"User '{user.name}' in {self.server} has requested the role "
                                  f"'{role_name}' which requires moderator verification.",
                            description='',
                            colour=COLOUR))

                    await interaction.followup.send(content=None,
                                                    embed=Embed(
                                                        title=f'Role Chosen: {role_name}',
                                                        description='A moderator will '
                                                                    'review your '
                                                                    'application and '
                                                                    'respond soon.',
                                                        colour=COLOUR),
                                                    ephemeral=True)

                elif role in self.user_roles.keys():
                    roles_managed = set()
                    for key in self.verifiable_user_roles.keys():
                        roles_managed.add(get(guild.roles, id=key))

                    for key in self.user_roles.keys():
                        roles_managed.add(get(guild.roles, id=key))

                    for role in roles_managed:
                        await user.remove_roles(role)

                    # grant the new role role_item
                    await user.add_roles(role_item)

                    await interaction.followup.send(content=None,
                                                    embed=Embed(
                                                        title=f'Role Chosen: {role_name}',
                                                        description='The role has been '
                                                                    'granted.',
                                                        colour=COLOUR),
                                                    ephemeral=True)
                    # await self.logging_channel.send(
                    #     f"<@{interaction.user.id}> updated their experience role at "
                    #     f"{asctime(localtime(time()))}")
            else:
                await interaction.followup.send(content=None,
                                                embed=Embed(
                                                    title="Verification Error",
                                                    description="You are not yet verified. "
                                                                "Please do so first.",
                                                    colour=COLOUR),
                                                ephemeral=True)


class BrandSelect(discord.ui.Select):
    # subclass of 'select', allowing for role manipulation
    def __init__(self, bot, brand_roles, server, server_id, welcome_role, placeholder,
                 logging_channel):
        self.logging_channel = logging_channel
        self.bot = bot
        self.roles = brand_roles
        self.server = server
        self.server_id = server_id
        self.welcome_role = welcome_role
        super(BrandSelect, self).__init__(placeholder=placeholder,
                                          max_values=len(brand_roles) / 2,
                                          min_values=0)

    async def callback(self, interaction: discord.Interaction):
        user = interaction.user
        role_ids_chosen = interaction.data['values']
        await interaction.response.defer()

        roles_managed = set()
        for key in self.roles.keys():
            guild = await self.bot.fetch_guild(server_id)
            role = get(guild.roles, id=key)
            roles_managed.add(role)
        for role in set(roles_managed) & set(user.roles):
            await user.remove_roles(role)

        roles_to_add = set()
        for key in role_ids_chosen:
            guild = await self.bot.fetch_guild(server_id)
            role = get(guild.roles, id=int(key))
            roles_to_add.add(role)
        await interaction.followup.send(content=None,
                                        embed=Embed(
                                            title='Brand Roles set!',
                                            description='** **',
                                            colour=COLOUR),
                                        ephemeral=True)
        for role in roles_to_add:
            await user.add_roles(role)
        # await self.logging_channel.send(f"<@{interaction.user.id}> updated their brand roles at "
        #                                 f"{asctime(localtime(time()))}")


class ContinentSelect(discord.ui.Select):
    def __init__(self, bot, brand_roles, server, server_id, welcome_role, placeholder,
                 logging_channel):
        self.logging_channel = logging_channel
        self.bot = bot
        self.roles = brand_roles
        self.server = server
        self.server_id = server_id
        self.welcome_role = welcome_role
        super(ContinentSelect, self).__init__(placeholder=placeholder)

    async def callback(self, interaction: discord.Interaction):
        user = interaction.user
        role_ids_chosen = interaction.data['values']
        await interaction.response.defer()

        roles_managed = set()
        for key in self.roles.keys():
            guild = await self.bot.fetch_guild(server_id)
            role = get(guild.roles, id=key)
            roles_managed.add(role)
        for role in set(roles_managed) & set(user.roles):
            await user.remove_roles(role)

        roles_to_add = set()
        for key in role_ids_chosen:
            guild = await self.bot.fetch_guild(server_id)
            role = get(guild.roles, id=int(key))
            roles_to_add.add(role)
        await interaction.followup.send(content=None,
                                        embed=Embed(
                                            title='Continent Roles set!',
                                            description='** **',
                                            colour=COLOUR),
                                        ephemeral=True)
        for role in roles_to_add:
            await user.add_roles(role)
        # await self.logging_channel.send(f"<@{interaction.user.id}> updated their continent "
        #                                 f"role at {asctime(localtime(time()))}")


def verification(bot, welcome_role_id, server_id, welcome_message, rules, channel_rules, roles,
                 verifiable_user_roles, logging_channel):
    embed_list = []
    embed_one = Embed(title='Rules',
                      description='Use the green button below to verify yourself when you '
                                  'have read and understood the rules.',
                      colour=COLOUR,
                      )
    embed_one.set_footer(text=("\u3000" * 300))

    for rule in rules.keys():
        embed_one.add_field(name=rule,
                            value=rules[rule] + '\n' if len(rules[rule]) > 2 else '\u200b\n',
                            inline=False)
    if len(rules.keys()) >= 1:
        embed_list.append(embed_one)

    embed_two = Embed(title='Channel Specific Rules and Guidelines',
                      description='\u3000',
                      colour=COLOUR
                      )
    embed_two.set_footer(text=("\u3000" * 300))

    for rule in channel_rules.keys():
        embed_two.add_field(name=rule,
                            value=channel_rules[rule] + '\n' if len(channel_rules[rule]) > 2
                            else '\u200b\n',
                            inline=False)
    if len(channel_rules.keys()) >= 1:
        embed_list.append(embed_two)

    verify_button = ButtonVerify(bot, welcome_role_id, server_id, welcome_message, roles,
                                 verifiable_user_roles, logging_channel=logging_channel)
    view = discord.ui.View(verify_button, timeout=None)
    return view, embed_list


def role_select(bot, user_roles, verifiable_user_roles, mod_channel, server_name, server_id,
                welcome_role_id, logging_channel):
    embed_description_string = "Use the drop-down to select a role, " \
                               "as appropriate."

    embed = discord.Embed(title='Set Your Role',
                          description=embed_description_string,
                          color=COLOUR
                          )
    embed.set_footer(text=("\u3000" * 300))

    for item in verifiable_user_roles.keys():
        embed.add_field(name=verifiable_user_roles[item][0],
                        value=' - ' + verifiable_user_roles[item][1] +
                              '\n- **This role requires verification by a moderator.**',
                        inline=False)

    for item in user_roles.keys():
        embed.add_field(name=user_roles[item][0],
                        value=' - ' + user_roles[item][1],
                        inline=False)

    role_select = RoleSelect(bot=bot, roles=user_roles, verifiable_roles=verifiable_user_roles,
                             mod_ping_channel=mod_channel,
                             server=server_name, server_id=server_id,
                             welcome_role=welcome_role_id,
                             placeholder='Pick a Role!',
                             logging_channel=logging_channel
                             )

    for item in verifiable_user_roles.keys():
        role_select.add_option(label=verifiable_user_roles[item][0],
                               value=item,
                               description='requires moderator approval.'
                               )

    for item in user_roles.keys():
        role_select.add_option(label=user_roles[item][0],
                               value=item,
                               description=''
                               )

    return discord.ui.View(role_select, timeout=None), embed


def brand_select(bot, brand_roles, server_name, server_id, welcome_role_id, logging_channel):
    embed_description_string = f"Use the drop-down to select up to {int(len(brand_roles) / 2)} " \
                               f"brands that you use regularly."

    embeds = []
    view = discord.ui.View(timeout=None)
    embed = discord.Embed(title='Brands',
                          description=embed_description_string,
                          color=COLOUR
                          )

    embed.set_footer(text=("\u3000" * 300))
    for i in range(0, len(brand_roles), 2):
        embed.add_field(name=f"**{brand_roles[list(brand_roles.keys())[i]]}**",
                        value=f"**{brand_roles[list(brand_roles.keys())[i + 1]]}**",
                        inline=True)

    for i in range(0, len(brand_roles), MAX_ITEMS_IN_EMBED):
        brand_roles_slice = {}
        for key in list(brand_roles.keys())[i:i + MAX_ITEMS_IN_EMBED]:
            brand_roles_slice[key] = brand_roles[key]
        brand_select_menu = BrandSelect(bot=bot,
                                        brand_roles=brand_roles_slice,
                                        server=server_name,
                                        server_id=server_id,
                                        welcome_role=welcome_role_id,
                                        placeholder="Choose from the available brands!",
                                        logging_channel=logging_channel)

        for item in brand_roles_slice.keys():
            brand_select_menu.add_option(label=brand_roles_slice[item],
                                         value=item,
                                         description='')
        view.add_item(brand_select_menu)

    embeds.append(embed)

    return view, embeds


def continent_select(bot, continent_roles, server_name, server_id, logging_channel):
    embed_description_string = "Choose a degree!"

    embeds = []
    view = discord.ui.View(timeout=None)
    embed = discord.Embed(title='Degrees',
                          description=embed_description_string,
                          color=COLOUR
                          )

    embed.set_footer(text=("\u3000" * 300))
    for i in range(0, len(continent_roles), 2):
        embed.add_field(name=f"**{continent_roles[list(continent_roles.keys())[i]]}**",
                        value=f"**{continent_roles[list(continent_roles.keys())[i + 1]]}**",
                        inline=True)
    for i in range(0, len(continent_roles), MAX_ITEMS_IN_EMBED):
        continent_roles_slice = {}
        for key in list(continent_roles.keys())[i:i + MAX_ITEMS_IN_EMBED]:
            continent_roles_slice[key] = continent_roles[key]
        continent_select_menu = ContinentSelect(bot=bot,
                                                brand_roles=continent_roles_slice,
                                                server=server_name,
                                                server_id=server_id,
                                                welcome_role=welcome_role_id,
                                                placeholder="Choose from the available degrees!",
                                                logging_channel=logging_channel)

        for item in continent_roles_slice.keys():
            continent_select_menu.add_option(label=continent_roles_slice[item],
                                             value=item,
                                             description='')
        view.add_item(continent_select_menu)

    embeds.append(embed)

    return view, embeds


robot = commands.Bot(command_prefix=prefix,
                     case_insensitive=True)


@robot.event
async def on_ready():
    # verification_channel = robot.get_channel(int(verification_channel_id))
    # async for message in verification_channel.history(limit=200):
    #     if message.author == robot.user:
    #         await message.delete()

    # roles_channel = robot.get_channel(int(roles_channel_id))
    # async for message in roles_channel.history(limit=200):
    #     if message.author == robot.user:
    #         await message.delete()

    brands_channel = robot.get_channel(int(brands_channel_id))
    async for message in brands_channel.history(limit=200):
        if message.author == robot.user:
            await message.delete()

    continents_channel = robot.get_channel(int(continents_channel_id))
    async for message in continents_channel.history(limit=200):
        if message.author == robot.user:
            await message.delete()

    logging_channel = 0

    # verification_view, verification_embeds = verification(bot=robot,
    #                                                       welcome_role_id=welcome_role_id,
    #                                                       server_id=server_id,
    #                                                       welcome_message=
    #                                                       "Welcome to ViewFinders!",
    #                                                       rules=rules,
    #                                                       channel_rules=channel_rules,
    #                                                       roles=roles,
    #                                                       verifiable_user_roles=verifiable_roles,
    #                                                       logging_channel=logging_channel
    #                                                       )

    experience_roles_view, experience_roles_embed = role_select(bot=robot,
                                                                user_roles=roles,
                                                                verifiable_user_roles=
                                                                verifiable_roles,
                                                                mod_channel=mod_ping_channel_id,
                                                                server_name=server_name,
                                                                server_id=server_id,
                                                                welcome_role_id=welcome_role_id,
                                                                logging_channel=logging_channel
                                                                )

    # brands_roles_view, brands_roles_embed = brand_select(bot=robot,
    #                                                      brand_roles=brands,
    #                                                      server_name=server_name,
    #                                                      server_id=server_id,
    #                                                      welcome_role_id=welcome_role_id,
    #                                                      logging_channel=logging_channel
    #                                                      )

    continents_roles_view, continents_roles_embed = continent_select(bot=robot,
                                                                     continent_roles=continents,
                                                                     server_name=server_name,
                                                                     server_id=server_id,
                                                                     logging_channel=logging_channel
                                                                     )

    # await verification_channel.send(embeds=verification_embeds, view=verification_view)
    await roles_channel.send(embed=experience_roles_embed, view=experience_roles_view)
    # await brands_channel.send(embeds=brands_roles_embed, view=brands_roles_view)
    await continents_channel.send(embeds=continents_roles_embed, view=continents_roles_view)


# @robot.event
# async def on_member_join(member):
#     await robot.get_channel(int(logging_channel_id)).send(f"<@{member.id}> "
#                                                           f"joined the server at "
#                                                           f"{asctime(localtime(time()))}")
#
#
# async def on_member_remove(member):
#     await robot.get_channel(int(logging_channel_id)).send(f"<@{member.id}> "
#                                                           f"left the server at "
#                                                           f"{asctime(localtime(time()))}")
#
#
# async def on_member_update(member):
#     await robot.get_channel(int(logging_channel_id)).send(f"<@{member.id}> "
#                                                           f"updated their profile at "
#                                                           f"{asctime(localtime(time()))}")
#
#
# async def on_member_ban(user):
#     await robot.get_channel(int(logging_channel_id)).send(f"<@{user.id}> "
#                                                           f"was banned at "
#                                                           f"{asctime(localtime(time()))}")
#
#
# async def on_member_unban(user):
#     await robot.get_channel(int(logging_channel_id)).send(f"<@{user.id}> "
#                                                           f"was unbanned at "
#                                                           f"{asctime(localtime(time()))}")


# IMPLEMENT THE REST OF HOWITZER HERE


robot.run(token)

